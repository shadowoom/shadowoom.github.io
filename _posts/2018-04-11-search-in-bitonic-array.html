---
type: algorithm_course
title: Search in bitonic array
---

<h5>Problem Description</h5>
<p> 
		<ul>
			<li>
			An array is bitonic if it is comprised of an increasing sequence of integers followed immediately by a decreasing sequence of integers. 
		</li>
		<li>
			Write a program that, given a bitonic array of n distinct integer values, determines whether a given integer is in the array.
		</li>
			<li>Standard version: Use ∼3lgn compares in the worst case.</li>
			<li>
				Signing bonus: Use ∼2lgn compares in the worst case (and prove that no algorithm can guarantee to perform fewer than ∼2lgn compares in the worst case).
			</li>
		</ul>
</p>

<h5>Personal Thoughts</h5>
<p>
	<ul>
			<li>
				Assume the array is of size n. The minimum value for n is 3. We can find the index of the turning point, t, in the array with ∼logn time through following procedure:
				<ul>
					<li>
						initialize l = 0, r = n – 1.
					</li>
					<li>
						get the middle item of the array, m = l + (r – l) / 2 => arr[m]
					</li>
					<li>
						compare arr[m] against the item right before it, a and the item right after it, b
					</li>
					<li>
						if arr[m] > a and arr[m] > b, return m
					</li>
					<li>
						if arr[m] > a and arr[m] < b, apply recursive call on the method (set l = m)
					</li>
					<li>
						if arr[m] < a and arr[m] > b, apply recursive call on the method (set r = m)
					</li>
				</ul>
			</li>
			<li>
				compare the search term, s with the turning point, arr[t]:
				<ul>
					<li>
						if s > arr[t], return – 1 (the search term is not in the array)
					</li>
					<li>
						else if s == arr[t], return t
					</li>
					<li>
						else, conduct an ascending binary search on the part before t (∼logn time) and a descending binary search on the part after t (∼logn time)
					</li>
				</ul>
			</li>
			<li>
				ascending binary search:
				<ul>
					<li>
						initialize l = 0, r = n – 1
					</li>
					<li>
						set up a while loop with terminating condition l <= r
					</li>
					<li>
						initialize  m = l + (r – l) / 2
					</li>
					<li>
						if arr[m] == s, return m
					</li>
					<li>
						else if arr[m] < s, l = m + 1
					</li>
					<li>
						else, r = m – 1 and if not found, return -1
					</li>
				</ul>
			</li>
			<li>
				descending binary search:
				<ul>
					<li>
						initialize l = 0, r = n – 1
					</li>
					<li>
						set up a while loop with terminating condition l <= r
					</li>
					<li>
						initialize  m = l + (r – l) / 2
					</li>
					<li>
						if arr[m] == s, return m
					</li>
					<li>
						else if arr[m] < s, r = m – 1
					</li>
					<li>
						else, l = m + 1 and if not found, return -1
					</li>
				</ul>
			</li>
		</ul>
	</p>

	<h5>Java Implementation</h5>

	<p>
		https://github.com/shadowoom/algorithm/blob/master/src/coursera/SearchBitonicArray.java
	</p>



<p>{{ page.date | date_to_string }}</p>